defmodule FnXML.ParserStreamTest do
  use ExUnit.Case, async: true

  alias FnXML.ParserStream
  alias FnXML.Parser

  describe "parse/2 with eager mode" do
    test "parses simple element" do
      xml = "<root><item>Hello</item></root>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses with attributes" do
      xml = ~s(<root id="1" class="main"><child attr="value"/></root>)
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses with namespaces" do
      xml = ~s(<root xmlns="http://example.com" xmlns:ns="http://ns.com"><ns:item/></root>)
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses comments" do
      xml = "<root><!-- this is a comment --><item/></root>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses CDATA sections" do
      xml = "<root><![CDATA[<not>parsed</not>]]></root>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses XML prolog" do
      xml = ~s(<?xml version="1.0" encoding="UTF-8"?><root/>)
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses processing instructions" do
      xml = "<root><?target data?></root>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles entity references" do
      xml = "<root>&lt;&gt;&amp;&apos;&quot;</root>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end
  end

  describe "parse/2 with lazy mode" do
    test "parses simple element" do
      xml = "<root><item>Hello</item></root>"
      stream_result = ParserStream.parse([xml], mode: :lazy) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses complex document" do
      xml = """
      <?xml version="1.0"?>
      <catalog>
        <book id="1">
          <title>Learning Elixir</title>
          <author>John Doe</author>
        </book>
        <book id="2">
          <title>Advanced OTP</title>
          <author>Jane Smith</author>
        </book>
      </catalog>
      """
      stream_result = ParserStream.parse([xml], mode: :lazy) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end
  end

  describe "chunked input" do
    test "handles chunks split at element boundaries" do
      chunks = ["<root>", "<item>Hello</item>", "</root>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles chunks split in middle of tag name" do
      chunks = ["<ro", "ot><item/></root>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles chunks split in middle of attribute" do
      chunks = ["<root attr=\"val", "ue\"/>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles chunks split in comment marker" do
      chunks = ["<root><!-", "- comment --></root>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles chunks split in CDATA marker" do
      chunks = ["<root><![CD", "ATA[content]]></root>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles 1-byte chunks (maximum boundary stress)" do
      xml = "<root><!-- comment --><![CDATA[data]]></root>"
      chunks = String.graphemes(xml)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles chunks split in prolog" do
      chunks = ["<?xml ", "version=\"1.0\"?>", "<root/>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles chunks split in closing comment marker" do
      chunks = ["<root><!-- comment -", "->text</root>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles chunks split in CDATA closing marker" do
      chunks = ["<root><![CDATA[data]", "]>text</root>"]
      xml = Enum.join(chunks)
      stream_result = ParserStream.parse(chunks, mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end
  end

  describe "File.stream! integration" do
    setup do
      xml = """
      <?xml version="1.0"?>
      <catalog>
        <book id="1">
          <title>Test Book</title>
          <price>29.99</price>
        </book>
      </catalog>
      """
      path = "/tmp/parser_stream_test_#{:rand.uniform(1_000_000)}.xml"
      File.write!(path, xml)
      on_exit(fn -> File.rm(path) end)
      {:ok, path: path, xml: xml}
    end

    test "parses file stream in eager mode", %{path: path, xml: xml} do
      stream_result = File.stream!(path, [], 64)
        |> ParserStream.parse(mode: :eager)
        |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses file stream in lazy mode", %{path: path, xml: xml} do
      stream_result = File.stream!(path, [], 64)
        |> ParserStream.parse(mode: :lazy)
        |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "parses file stream with small chunks", %{path: path, xml: xml} do
      stream_result = File.stream!(path, [], 8)
        |> ParserStream.parse(mode: :lazy)
        |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end
  end

  describe "default mode is lazy" do
    test "defaults to lazy mode when not specified" do
      xml = "<root><item>test</item></root>"
      result = ParserStream.parse([xml]) |> Enum.to_list()
      expected = Parser.parse(xml) |> Enum.to_list()
      assert result == expected
    end
  end

  describe "empty and edge cases" do
    test "handles empty element" do
      xml = "<root/>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles whitespace-only content" do
      xml = "<root>   </root>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles deeply nested elements" do
      xml = "<a><b><c><d><e><f>deep</f></e></d></c></b></a>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end

    test "handles mixed content" do
      xml = "<root>text<child/>more text</root>"
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert stream_result == parser_result
    end
  end

  describe "callback-based parsing" do
    test "parse/3 calls callback for each event" do
      xml = "<root><item>test</item></root>"
      collector = fn event -> send(self(), {:event, event}) end

      ParserStream.parse([xml], collector, mode: :eager)

      expected_events = Parser.parse(xml) |> Enum.to_list()
      received_events = collect_messages([])

      assert received_events == expected_events
    end
  end

  defp collect_messages(acc) do
    receive do
      {:event, event} -> collect_messages([event | acc])
    after
      0 -> Enum.reverse(acc)
    end
  end

  describe "DOCTYPE handling" do
    # Helper to normalize events for comparison (prolog and close tag formats differ)
    defp filter_events(events) do
      events
      |> Enum.reject(fn
        {:doc_start, _} -> true
        {:doc_end, _} -> true
        {:prolog, _, _} -> true
        {:prolog, _, _, _} -> true
        _ -> false
      end)
      |> Enum.map(fn
        # Normalize close tags - Parser sometimes omits loc for self-closing
        {:close, name} -> {:close, name}
        {:close, name, _loc} -> {:close, name}
        other -> other
      end)
    end

    @tag timeout: 5000
    test "parses simple DOCTYPE SYSTEM declaration" do
      xml = ~s(<?xml version="1.0"?><!DOCTYPE root SYSTEM "test.dtd"><root>test</root>)
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      # Compare events excluding prolog (format differs between parsers)
      assert filter_events(stream_result) == filter_events(parser_result)
      # DOCTYPE should be skipped, root element events should be present
      assert Enum.any?(stream_result, fn
        {:open, "root", _, _} -> true
        _ -> false
      end)
    end

    @tag timeout: 5000
    test "parses DOCTYPE PUBLIC declaration" do
      xml = ~s(<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><body/></html>)
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert filter_events(stream_result) == filter_events(parser_result)
    end

    @tag timeout: 5000
    test "parses DOCTYPE with internal subset" do
      xml = """
      <?xml version="1.0"?>
      <!DOCTYPE note [
        <!ELEMENT note (to,from,heading,body)>
        <!ELEMENT to (#PCDATA)>
        <!ELEMENT from (#PCDATA)>
        <!ELEMENT heading (#PCDATA)>
        <!ELEMENT body (#PCDATA)>
      ]>
      <note><to>User</to><from>System</from><heading>Test</heading><body>Hello</body></note>
      """
      stream_result = ParserStream.parse([xml], mode: :eager) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert filter_events(stream_result) == filter_events(parser_result)
    end

    @tag timeout: 5000
    test "parses DOCTYPE with lazy mode" do
      xml = ~s(<?xml version="1.0"?><!DOCTYPE root SYSTEM "test.dtd"><root>test</root>)
      stream_result = ParserStream.parse([xml], mode: :lazy) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert filter_events(stream_result) == filter_events(parser_result)
    end

    @tag timeout: 5000
    test "parses DOCTYPE in chunked stream" do
      xml = ~s(<?xml version="1.0"?><!DOCTYPE root SYSTEM "test.dtd"><root>test</root>)
      # Split into 10-byte chunks to test boundary handling
      chunks = for <<chunk::binary-size(10) <- xml>>, do: chunk
      chunks = chunks ++ [binary_part(xml, length(chunks) * 10, byte_size(xml) - length(chunks) * 10)]
      stream_result = ParserStream.parse(chunks, mode: :lazy) |> Enum.to_list()
      parser_result = Parser.parse(xml) |> Enum.to_list()
      assert filter_events(stream_result) == filter_events(parser_result)
    end
  end
end
